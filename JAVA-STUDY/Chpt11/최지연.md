## ch11.컬렉션 프레임웍(collections framework)
- 컬렉션(collection) : 여러 객체(데이터)를 모아 놓은 것을 의미
- 프레임웍(framwork) : 표준화, 정형화된 체계적인 프로그래밍 방식
<br>
 
- 컬렉션 프레임웍(collection framework)     
-컬렉션(다수의 객체)을 다루기 위한 표준화된 프로그래밍 방식    
-컬렉션을 쉽고 편리하게 다룰 수 있는(저장, 삭제, 검색, 정렬) 다양한 클래스 제공    
-java.util패키지에 포함. JDK1.2부터 제공     
<br>

 - 컬렉션 클래스(collection class)    
다수의 데이터를 저장할 수 있는 클래스(ex. Vector, ArrayList, Hashset)    
<br>

### 컬렉션 프레임웍의 핵심 인터페이스
List , Set, Map      
- List : 순서가 있는 데이터의 집합. 데이터의 중복을 허용 ex) 대기자 명단
  - 구현클래스 : ArrayList, LinkedList, Stack, Vector 등         
- Set : 순서를 유지하지 않는 데이터 집합. 데이터의 중복을 허용하지 않음 ex) 양의 정수집합, 소수의 집합    
  - 구현클래스 : HashSet, TreeSet 등     
- Map : 키(key)와 값(value)의 쌍(pair)으로 이루어진 데이터의 집합. 순서 유지X, 키 중복X ,값 중복O    
  - 구현클래스 : HashMap, TreeMap, Hashtable, Properties 등     

### Map인터페이스
|메서드|설명|
|------|---------------|
|Set entrySet()|Map에 저장되어 있는 key-value쌍을 Map.Entry타입의 객체로 저장한 Set으로 반환한다.|
|Set keySet()|Map에 저장된 모든 key객체를 반환한다.|
|Collection values()|Map에 저장된 모든 value객체를 반환한다.|    
> - 키와 값 한 쌍을 entry라고 한다.     
> - 반환타입이 Set : 순서X 중복X      
> - 반환타입이 Collection : 순서OX 중복 OX (=List와 Set 어떤 결과도 와도 된다.)   

### ArrayList
- ArrayList는 기존의 Vector를 개선한 것으로 구현원리와 기능적으로 동일(Vector는 자체 동기화처리O)    
- xxList : List인터페이스를 구현. 저장순서 유지, 중복 허용    
- 데이터의 저장공간으로 배열을 사용(배열기반)
```java
public class Vector extends AbstractList
     implements List, RandomAccess, Cloneable, java.io.Serializable
  {  ...
    protected Object[] elementData;  // 객체를 담기 위한 배열. 모든 종류의 객체 저장 가능 feat.다형성
     ...
  }
```
예제
```java
class Ex11_1 {
    public static void main(String[] args) {
        // 기본 길이(용량, capacity)가 10인 ArrayList를 생성
        ArrayList list1 = new ArrayList(10);
        // ArrayList는 객체배열이기 때문에 객체만 저장가능
        // list1.add(5);
        // 하지만 위와 같이 해도 무방 
        // why? autoboxing에 의해 기본형이 참조형으로 자동 변환
        list1.add(new Integer(5));
        list1.add(new Integer(4));
        list1.add(new Integer(2));
        list1.add(new Integer(0));
        list1.add(new Integer(1));
        list1.add(new Integer(3));
        
        // Collection은 인터페이스, Collections는 유틸 클래스
        Collections.sort(list1);  // [0, 1, 2, 3, 4, 5]
        
        list1.add(0, "1");  // [1, 0, 1, 2, 3, 4, 5]
        list1.remove(1); // 인덱스가 1인 객체(0)를 삭제
        list1.remove(new Integer(1)); // 1을 삭제
    }
}
```
### LinkedList - 배열의 장단점을 보완한!
장점 : 배열은 구조가 간단하고 데이터를 읽는데 걸리는 시간(접근시간, access time)이 짧다.     
단점 : 1. 크기를 변경할 수 없다(새로운 배열 생성 후 데이터 복사 / 충분히 큰 배열 생성시 메모리가 낭비됨) 2. 비순차적인 데이터의 추가, 삭제에 시간이 많이 걸린다.     

- LinkedList : 배열과 달리, LinkedList는 불연속적으로 존재하는 데이터를 연결(link)
 ```java
 class Node {
   Node next;    // 다음 노드
   Object obj;   // 데이터
 }
 ```    
 - 데이터의 삭제 : 단 한 번의 참조변경만으로 가능
 - 데이터의 추가 : 한번의 Node객체생성과 두 번의 참조변경만으로 가능

 
 
