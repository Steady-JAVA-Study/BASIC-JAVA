1# 1. 변수란
## JAVA의 변수 선언 방법
`변수타입 변수이름 ;`
```
int cakeNumber;
```
- 변수 선언 시 메모리의 빈 공간에 `변수타입`	에 알맞은 크기의 저장공간 확보
- 이 저장공간은 `변수이름`을 통해 사용 가능

- 지역변수는 사용되기 전 반드시 초기화 needed
- BUT 클래스 변수와 인스턴스 변수는 초기화 생략 가능

## 변수의 명명 규칙
1) 대소문자 구분, 길이 제한 X 
2) 예약어 사용 X
3) 숫자 시작 X
4) 특수문자는 `_` , `$` 만 사용 가능

## 권장 규칙
1) 클래스 이름 첫 글자는 대문자
- 변수와 메소드 이름의 첫 글자는 소문자
2) 캐멀
3) 상수 이름은 모두 대문자로 진행

# 2. 변수의 타입
- 자료형 : data의 종류에 따라 값이 저장될 공간의 저장형식을 정의한 것 

> #### `자료형 (data type) vs 타입 (type)`
1) **기본형** : 저장할 **값(data)의 종류** 따라서 구분 => 자료형
2) **참조형** : 객체의 주소 저장 => 값이 아닌 **객체의 종류(type)** 에 의해 구분

(사실상 type이 data type을 포함하는 개념이라 가볍게 읽고 넘어가도 ok)

## 기본형 vs 참조형
1) **기본형** (primirive)
- 실제 값을 가진다.
- boolean, char, byte-short-int-long, float-double

2) **참조형** (reference)
- 어떤 값이 저장돼있는 주소를 값으로 가진다.
- 참조형 변수를 선언할 때는 변수의 타입으로 클래스 이름 사용, 클래스 이름이 참조변수의 타입이 된다.
- 새로운 클래스를 생성 == 새로운 참조변수를 만들어내는 것

```
`참조변수의 초기화`

Date today = new Date();

```
- Date 객체를 생성해서 그 주소를 today라는 참조변수에 저장
- 참조 변수는 null 또는 객체 주소를 값으로 가진다.

## 상수

- **값을 한번만 저장** 가능한 수 
- 변수랑 선언하기 똑같은데 final 을 붙여주어야 함
- **선언과 동시에 초기화** needed => 한번 값 설정해준 뒤 수정 불가능, 

> #### 리터럴 vs 상수
- 리터럴에 의미있는 이름을 붙인 것이 상수!!
- 리터럴은 그 변수 그 자체! 

## String 

- String도 클래스라서 new 로 새로 만들어줘야 하는데, String은 특별히
```
String str = "!!";
```
이런 식으로 해도 되고 new 로 만들어줘도 된다.

# 3. 기본형 (primitive type) 
1) 논리형 : true / false / 기본값은 false
2) 문자형 : char 단 하나의 문자
- 사실은 문자가 아닌 문자의 유니코드(정수)가 저장
```
(ex)
char ch = 'A';
char ch = 65;

=> 동일한 결과
```

3) 정수형 - byte / short / int / long
4) 실수형 - float / double

# 4. 기본형의 형변환

- 서로 다른 타입 간의 연산을 수행하기 위해 타입 일치시키기 => 형변환

> 형변환 : 변수, 또는 상수의 타입을 다른 타입으로 변환시키기

### 1) 형변환 방법
```
(타입) 피연산자
```

- 기본형과 참조형간의 형변환은 불가능
- float 타입의 값을 int 타입으로 변환할 때 소수점 이하의 값은 버림으로 처리 (반올림x)

### 2) 정수형간의 형변환
> 큰 타입 ➡ 작은 타입  : **값손실** 일어날 가능성 존재

> 작은 타입 ➡ 큰 타입 : 값 손실 발생 x , 나머지 빈공간은 0 또는 1로 채워져버리기


### 3) 정수형 - 실수형 간의 형변환

> 정수형 ➡ 실수형
- 실수형은 정수형보다 훨씬 큰ㅇ 저장 범위
#### 3-1 ) 정수형을 실수형으로 변환은 무리 x
#### 3-2 ) 실수형을 정수형으로 변환
- 실수형의 소수점 이하 값은 버려진다


# 5. 자동 형변환
- 서로 다른 타입 간의 대입이나 연산 수행 시, 형변환으로 타입 일치시키는 것이 원칙
- but!!! 형변환 생략 가능 경우도 존재 (암묵적으로 형변환이 수행이 된다.)

> ### 자동 형변환의 규칙
- 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환
`값 손실이 없는 경우!?`
   - 아까도 썼지만, 작은 아이가 큰 아이로 변하는 것은 값손실이 없다.
   - 반대로 큰 아이가 작은 아이로 변하면 값손실 발생
- 따라서 자동형변환은 작은 자료형이 큰 자료형으로 캐스팅 될 때 가능


### 큰 = 작 (가능) - 값손실 없음
- 이 경우에는 작은 아이가 왼쪽의 큰 아이로 할당되는, 작은 아이가 큰 아이로 변하는 값손실이 일어나지 않는 보존 상태 => 자동 캐스팅 가능

### 그러면 정수랑 실수는 어떻게 대소비교?

- 보통 자료형 크기가 클수록 표현범위가 크지만, 실수형은 정수형과 값 표현 방식 다름
=> 같은 크기라도 실수형이 정수형보다 훨씬 더 큰 표현범위를 가진다. 

![](https://velog.velcdn.com/images/myway00/post/c4e5cb3a-99e7-41e0-bcf4-07d59e64d2aa/image.png)

그림 출처 ㅣ https://blog.naver.com/PostView.nhn?blogId=jysaa5&logNo=221832417403&parentCategoryNo=&categoryNo=121&viewDate=&isShowPopularPosts=true&from=search

- 값의 범위가 작은 타잊에서 큰 타입으로의 형변환은 생략이 가능