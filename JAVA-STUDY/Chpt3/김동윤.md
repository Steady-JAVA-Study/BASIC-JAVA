# 연산자의 우선순위와 결합규칙
## 연산자의 우선순위
- 우선순위 확실하지 않으면 먼저 계산돼야할 부분 괄호로 묶어주면 됨
____
> - <<는 덧셈보다 우선순위 낮음
```
x << 2 + 1
```
이는 `x << (2 + 1 )` 과 같음
- 비트연산자(&)는 비교연산자(==, > , < , != ,, 크기 같음 여부) 보다 낮음
- AND 의미하는 &,&& 가 OR을 의미하는 |,|| 보다 우선순위 높음

## 연산자의 결합규칙
> 1) 산술 - 비교 - 논리 - 대입 순으로 수행
2) 단항 - 이항 - 삼항 순으로 수행
3) 단항 연산자와 대입 연산자 제외 모든 연산 진행방향은 왼 -> 오

## 산술 변환
> **연산 수행 직전에 발생하는 피연산자의 자동 형변환**
1) 두 피연산자의 타입을 같게 일치
2) 피연산자 타입이 INT보다 작은 타입이면 INT 로 변환

- 이항 연산자는 두 피연산자 타입이 일치하는 경우에 연산 가능
- 피연산자의 타입이 서로 다르다면 연산 전에 형변환 연산자로 타입 일치시키기
- 연산 전에 피연산자 타입의 일치를 위해 자동 형변환되는 것을 산술변환이라고 함

> **산술변환의 규칙**
- 1) 두 피연산자의 타입을 같게 일치시킨다 ( 둘 중 보다 큰 타입으로 일치시킨다)
- 2) 피연산자 타입이 INT보다 작은 타입이면 INT 로 변환
=> 이유 : 정수형의 기본타입 int가 가장 효율적으로 처리할 수 있는 타입이라서
=> 그리고 int보다 작은 char, short는 표현범위가 좁, 연산 중 오버플로우 발생 가능성 높음

## 전위형, 후위형 

1) 전위
> - j = ++i
는  아래 과정과 같다.
- 1) ++i
- 2) j=i

만약 i=5, j=0 라고 한다면
```
i++ (6)
j=i (6)


j=6 i=6
```
_____
2) 후위
> - j = i++
는  아래 과정과 같다.
- 1) j=i
- 2) i++

만약 i=5, j=0 라고 한다면
```
j=i (5)
i++ (6)

j=5 i=6
```

- 식이 복잡해질 위험 있어서 식에 두번 이상 포함된 변수에 증감연산자 사용은 피하기

## 산술 연산자
- 피연산자가 정수형인 경우, 나누는 수로 0 사용 금지 => ArithmeticException
컴파일은 가능 (우리가 쓴 코드를 기계어로)
그러나 런타임에러 발생할 것 (운영체제 상 에러)

## 연산 주의사항

- 크기가 작은 자료형 변수를 큰 변수형에 저장시 자동 형변환 (캐스팅)
- 반대인 경우는 그냥 하면 에러, 따라서 명시적 형변환 연산자 보태기 필요
```
byte a = 10;
byte b = 5;
byte c = a * b //에러, byte, char , short는 연산 시 자동으로 int로 바뀜
byte c = (byte) (a*b)
```

## 문자를 숫자로 변경하기
- 문자 에서 0을 빼주면 된다
```
'2'(문자 유니코드 50) -'0' (문자 유니코드 48) -> 2
'd' - 'a' => 100-97 = 3

```

(+) 기본 연산자
1) 반올림 
Math.round() => 간단 반올림 가능
2) 나머지 연산자 %


## 비교 연산자
- 문자열 비교 시에는 equals 만 가능하다
- == 는 단순 문자열 같음 여부가 아닌, 주소 여부로 체크 (동일한 객체인지)

### 효율적인 연산하기 ***
1) OR의 경우 (||)
- 두 피연산자 중 한 쪽만 `참`이어어도 전체가참이라서 좌측의 피연산자가 참이면 우측은 평가하지 않는다

**=> 따라서 OR은 참일 확률이 높은 조건을 앞에세워둬야지 더 빠르게 작동 가능**

2) AND의 경우(&&)
- 두 피연산자 중 한쪽만 `거짓`이어도 전체 연산 결과가 거짓이므로 좌측이 거짓이면 우측은 평가하지 않음

**=> 따라서 AND는 거짓일 확률이 높은 조건을 앞에 세워둬야지 더 빠르게 작동 가능**

```java
class Test{
	public static void main(String[] args) { 
		int a = 5;
		int b = 0;

		System.out.printf("a=%d, b=%d%n", a, b);
		System.out.printf("a!=0 || ++b!=0 = %b%n", a!=0 || ++b!=0);
		System.out.printf("a=%d, b=%d\n", a, b);
		System.out.printf("a==0 && ++b!=0 = %b%n", a==0 && ++b!=0);
		System.out.printf("a=%d, b=%d%n", a, b);
	} // mainÀÇ ³¡
}
```
- 원래는 b가 증가돼야 하는데, 이미 앞에서 결정이 돼버려서 연산자가 수행 x 반영 x