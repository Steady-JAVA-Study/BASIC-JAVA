# 1.연산자
###  1.1 연산자와 피연산자
연산자(operator) : 연산을 수행하는 기호(+,-<*,/ 등)   
피연산자(operand) : 연산자의 작업 대상(변수, 상수, 리터럴, 수식)     
- 연산자는 피연산자로 연산을 수행하고 나면 항상 **결과값** 을 반환한다.   

### 1.2 식과 대입 연산자
식 : 연산자와 피연산자를 조합하여 계산하고자하는 바를 표현한 것       
'식을 평가한다' : 식을 계산하여 결과를 얻는 것    
```java
int x = 5;
4 * x + 3;
```
식이 평가되어 23이라는 결과를 얻었지만, 결과는 어디 쓰이지 않고 사라짐   
따라서, 대입 연산자(=)를 사용해서 변수와 같이 값을 저장할 수 있는 공간에 결과를 저장해야 함
```java
int x = 5;
y = 4 * x + 3;
```
### 1.3 연산자의 종류
|종류|연산자|설명|
|:---:|:----------------:|-----------------------|
|산술| + - * / % << >> | 사칙연산과 나머지 연산(%) |
|비교| > < >= <= == != | 크고 작음과 같고 다름을 비교 |
|논리| &&  &#124;&#124;  !  &  &#124; ^ ~ |'그리고(AND)'와 '또는(OR)'으로 조건을 연결|
|대입|=|우변의 값을 좌변에 지정|
|기타|(type) ?: instanceof |형변환 연산자, 삼항 연산자, instanceof연산자|<br/>


### 1.4 연산자의 우선순위와 결합규칙
> 1. 산술>비교>논리>대입. 대입은 제일 마지막에 수행된다.   
> 2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자의 우선순위보다 높다.   
> 3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 **왼쪽에서-->오른쪽** 이다.   

### 1.5 산술 변환
연산 전에 피연산자 타입의 일치를 위해 자동 형변환되는 것    
산술 변환은 이항 연산뿐만 아니라 단항 연산에서도 일어난다. 규칙은 다음과 같다.   
  1. 두 피연산자의 타입을 같게 일치시킨다. (보다 **큰** 타입으로 일치)
```java     
      long + int  ->  long + long  ->  long   
      float + int  ->  float + float  ->  float   
      double + float  ->  double + double  ->  double      
```
  2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.
```java
      byte + short  ->  int + int  ->  int   
      char + short  ->  int + int  ->  int   
```
(예외: 쉬프트 연산자, 증갑 연산자)
# 2.단항 연산자
### 2.1 증감 연산자
피연산자에 저장된 값을 1 증가 또는 감소시킨다.    
증감 연산자의 피연산자로 정수와 실수가 모두 가능하지만, 상수는 값을 변경할 수 없으므로 가능하지 않다.   
|타입|설명|예시|
|:---:|:------------------:|------------|
|전위형|값이 참조되기 **전에** 증가시킨다.|j = ++i;|
|후위형|값이 참조된 **후에** 증가시킨다.|j = i++;|
### 2.2 부호 연산자
피연산자의 부호를 반대로 변경한 결과를 반환.   


# 3.산술 연산자
### 3.1 사칙 연산자
- 연산의 결과가 정확히 나올 수 있도록 형변환을 신경써야 한다!
```java
class OperatorEx6 {
     public static void main(String[] args) {
          byte a = 10;
          byte b = 20;
          byte c = (byte)(a + b);
          System.out.println(c);
     }
}
```
위 예제에서 (a + b)를 byte로 형변환 시키지 않고 컴파일하면 에러가 발생한다. [참고 : 1.5 산술변환 - 규칙2]       
a와 b는 모두 int형보다 작은 byte형이기 때문에 연산자'+'는 이 두 개의 피연산자들의 자료형을 int형으로 변환한 다음 연산을 수행한다.   
 
   
그 경우 'a+b' 연산결과는 byte형이 아닌 int형(byte)이고,     
4byte의 값을 1byte의 변수(c)에 형변환없이 저장하려고 했기 때문에 에러가 발생하는 것이다.   
    
- 사칙연산의 피연산자로 숫자뿐만 아니라 문자도 가능하다.    
  문자는 실제로 해당 문자의 유니코드(부호없는 정수)로 저장되므로 문자간의 사칙연산은 정수간의 연산과 동일하다.   
```java
class OperatorEx12 {
     public static void main(String[] args) {
          char c1 = 'a';         // c1에는 문자 'a'의 코드값인 97이 저장된다. 
          char c2 = c1;          // c1에 저장되어 있는 값이 c2에 저장된다.
          char c3 = ' ';         // c3을 공백으로 초기화한다.
          
          int i = c1 + 1;        // 'a' + 1 -> 97 + 1 -> 98
          
          c3 = (char) (c1 + 1);  // 덧셈연산 c1+1의 결과가 int이므로 이 결과를 char형 변수에 담으려면 char형으로 형변환 필요
                                 // 만일 c3 = 'a'+1; 이면 형변환 필요 X ('a'+1은 리터럴 간의 연산이고, 상수 또는 리터럴 간의 연산은 컴파일러가 미리 수행)
          System.out.println(c3);
     }
}
```

### 3.2 나머지 연산자
왼쪽의 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 결과로 반환하는 연산자   
- 나누는 수(오른쪽 피연산자)로 0을 사용할 수 없다.
- 피연산자로 **정수만** 허용된다.    
```java
class OperatorEx20 {
     public static void main(String[] args) {
          System.out.println(-10 % 8);   // -2
          System.out.println(10 % -8);   //  2 
          System.out.println(-10 % -8);  // -2
     }
}
```
그냥 피연산자의 부호를 모두 무시하고, 나머지 연산을 한 결과에 왼쪽 피연산자(나눠지는 수)의 부호를 붙이면 된다.   


# 4.비교 연산자
- 두 피연산자를 비교하는데 사용되는 연산자
- 주로 조건문과 반복문의 조건식에 사용
- 오직 true와 false 둘 중의 하나     
    
    
### 4.1 대소비교 연산자 < > <= >=
  - 두 연산자의 값의 크기를 비교
  - 참이면 true, 거짓이면 false를 반환
  - 기본형 중에서는 boolean형을 제외한 나머지 자료형에 다 사용가능. **참조형에는 사용불가**     

### 4.2 등가비교 연산자
  - 두 피연산자의 값이 같은지/다른지를 비교
  - **모든 자료형** 에 사용가능    
    (기본형 : 변수에 저장되어 있는 값이 같은지, 참조형 : 두 개의 피연산자(참조변수)가 같은 객체를 가리키고 있는지)
  - 기본형과 참조형은 서로 형변환이 불가능하기 때문에 등가비교 연산자로 둘을 비교할 수 없음
    
> '10.0==10.0f'는 true인데, '0.1==0.1f'는 false라니!   


> 문자열 비교는 '==' 대신 equals()라는 메서드를 사용해야해!



# 5.논리 연산자
### 5.1 논리 연산자 - &&, ||, !
- 효율적인 연산    
논리 연산자의 특징 중 하나는 효율적인 연산을 한다는 것이다.   
i) OR연산자'||'의 좌측 피연산자가 'true'이면, 우측 피연산자의 값은 평가하지 않는다.   
ii) AND연산자'&&'의 좌측 피연산자가 'false'이면, 우측 피연산자의 값은 평가하지 않는다.   
따라서, 같은 조건식이라도 피연산자의 위치에 따라서 연산속도가 달라질 수 있다!   
    
> 논리 부정 연산자 !
이 연산자는 피연산자가 true이면 false를, false이면 true를 반환한다.     
논리 부정 연산자'!'를 활용하여 toggle button을 논리적으로 구현하거나, 식을 보다 쉽게 작성할 수 있다.    
```java
//둘은 '문자 ch는 소문자가 아니다'라는 동일한 조건이다.
    ch < 'a' || ch > 'z' 
   !('a' <= ch && ch <= 'z')
```


### 5.2 비트 연산자

# 6.그 외의 연산자
### 6.1 조건 연산자
### 6.2 
