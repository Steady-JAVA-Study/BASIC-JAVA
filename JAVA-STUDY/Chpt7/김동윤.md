1# 1.상속
## 1.1 상속의 정의와 장점
상속을 받을 때
- 생성자와 초기화 블럭은 상속되지 않는다, 오로지 멤버만 상속
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다
- 상속을 받게 되면 조상클래스만 변경돼도 모든 자손 클래스에, 손자 클래스까지 영향 
=> 클래스 간 상속관계 맺어준다면 자손 클래스들의 공통적인 부분은 조상클래스에서 관리, 자손 클래스는 자신에 정의된 멤버들만 관리 
=> 관리 easy
- 자손 클래스의 인스턴스 생성 시, 조상 클래스의 멤버도 함께 생성
=> 따로 조상 클래스의 인스턴스 생성 안해도 조상 클래스 멤버 사용 가능

> A는 B이다 => `상속관계` (자손-조상)
> A는 B를 가진다 => `포함관계` (A 클래스에 B클래스 포함시키기)
- 프로그램의 모든 클래스를 분석해 가능한 많은 관계 맺도록 노력해, 코드의 재사용성 높이기 

## 1.4 단일 상속
- 자바에서는 단일 상속만을 허용
=> 클래스 간 관계가 명확 , 코드 더 신뢰 가능 
- 다중 상속을 허용 시 클래스 간 관계가 매우 복잡, 서로 다른 클래스로부터 상속받은 멤버 간의 이름이 같은 경우 구별 X 라는 단점 

# 2. 오버라이딩
- 상속받은 메서드의 내용을 변경하는 것 
> `오버라이딩의 조건`
1) 이름이 같기
2) 매개변수 같기
3) 반환타입 같기

> `조상클래스의 메서드를 자손 클래스에서 오버라이딩할 때`
1) 접근 제어자를 조상 클래스 메서드보다 좁은 범위로 변경 불가능
2) 예외는 조상클래스 메서드보다 많이 선언 X
3) 인스턴스 메서드를 static 메서드로 또는 그 반대로 변경 x

## 2.3 오버로딩 vs 오버라이딩

- 오버로딩 : 기존에 없는 새로운 new 메소드 정의 (new)
- 오버라이딩 : 상속받은 메서드 내용 변경 (modify, change)

## 2.4 super
- super : 자손 클래스에서 조상클래스로부터 상속받은 멤버 참조하는데 사용되는 참조 변수
- 멤버변수와 지역변수 간의 이름 the same할 때 this로 구별했듯, 상속받은 멤버와 자신의 멤버와 이름이 같을 때 super을 붙이는 것 

- 인스턴스 메소드에서는 자신이 속한 인스턴스 주소가 지역변수로 저장, 이는 참조변수인 this와 super의 값이 됨

> 조상의 멤버와, 자신의 멤버를 구별한다는 데 사용되는 점을 제외하고는 super, this는 근본적으로 the same

- static 메소드는 인스턴스와 관련 x, 따라서 this 와 마찬가지로 super 역시 statuc에선 쓸 수 없음 

![](https://velog.velcdn.com/images/myway00/post/6703e039-6c75-4390-ba76-dc9f7def10f6/image.png)

## 2.5 super() - 조상클래스 생성자
> this() : 같은 클래스의 다른 생성자 호출에 사용
super() : 조상 클래스의 생성자 호출에 사용

- 자손 클래스 인스턴스 생성 시 , 자손의 멤버와 조상의 멤버가 모두 합쳐진 하나의 인스턴스 생성
- 자손 클래스의 인스턴스가 조상 클래스의 멤버들을 사용 가능
=> 이를 위해서는 조상 클래스 멤버의 초기화 작업 수행 필요
=> 자손 클래스 생성자에서 조상 클래스 생성자 호출돼야 함

- 생성자 첫 줄에서 조상 클래스 호출이유는, 자손 클래스의 멤버가 조상 클래스 멤버 사용할 수도 있어서, 조상 멤버들이 먼저 초기화 needed 

- Object 클래스 제외한 모든 클래스의 생성자 첫 줄에, 생성자, this() 또는 super() 을 호출해야 한다, 그렇지 않으면 컴파일러가 자동적으로 super()을 생성자 첫 줄에 삽입 

# 4. 제어자
> - 접근 제어자 : public, protected,  default, private
=> 접근 제어자는 한번에 하나만 선택 가능

## 4.2 static : 클래스의, 공통적인 
- static : 클래스의, 공통적인

- 클래스 변수는 인스턴스에 관계 없이 같은 값을 가진다.
- 하나의 변수를 모든 인스턴스가 공유하기 때문
- static이 붙은 멤버변수와 메서드, 초기화 블럭은 인스턴스가 아닌 클래스에 관계된 것, 인스턴스 생성 않고도 사용 가능

## 4.3 final : 마지막의, 변경될 수 없는

- 변수에 사용되면 값을 변경할 수 없는 상수
- 메서드에 사용되면 오버라이딩 불가
- 클래스에 사용되면 자신을 확장하는 자손 클래스 정의 x
=> final은 변경 불가, 오버라이딩 재정의 부락, final 지정 클래스는 조상 클래스 될 수 없음

## 4.4 abstract : 추상의, 미완성의
- 메서드의 선언부만 작성, 실제 수행내용은 구현치 않은 추상메소드 선언하며 사용
- 추상 클래스는 아직 완성되지 않은 메서드가 존재하는 미완성 설계도! => 인스턴스 생성 불가

## 4.5 접근 제어자
> private 자신 클래스 안에서만 가능
default 같은 패키지 내
protected 같은 패키지 내 + 다른 패키지의 자손 클래스에서 접근 가능
public 접근 제한 어디서나

- 접근제어자 => 캡슐화의 기능 제공
> 1) 외부로부터 데이터 보호 위해
2) 외부에는 불필요한 내부적으로만 사용되는 부분 감추기 위함

## 4.6 제어자의 조합
> 1. 메서드에 static과 absract 함께 사용 불가능
- static은 몸통이 있는 메서드에서만 사용 가능
2. 클래스에 abstract와 final 동시 사용 불가
- final 은 클래스 확장 x, abstract는 상속 통해 완성돼야 한다는 것=> 서로 모순
3. abstract메서드의 접근 제어자가 private일 수 없음
- abstract메서드는 자손클래스에서 구현해줘야 하는데, 접근 제어자가 private이면 자손클래스에서 접근 불가능

# 5. 다형성
- 여러가지 형태를 가질 수 있는 능력
- 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있게 하는 것 

> - 조상 타입의 참조변수로 자손타입의 인스턴스 참조 가능
   - 그러나 자손에서 추가로 정의한 메소드에는 접근 불가!
- 반대로 자손타입의 참조변수로 조상타입의 인스턴스 참조 불가능
   - 조상타입의 인스턴스 참조 허용하면 존재하지 않는 멤버 사용하고자 할 가능성 존재, 허용 x, 
   
! 참조 변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 한다 

## 5.2 형변환

> 자손타입 -> 조상타입 (업캐스팅) - 형변환 생략 오케이
조상타입 -> 자손타입 (다운캐스팅) - 형변환 생략 불가

- 상속 관계가 아닌 클래스 간 형변환 불가
- 조상 = 자손 의 형태는 업캐스팅 (조상<-자손) - 형변환 캐스팅 필요 없음 
- 자손 = (자손캐스팅)조상 은 다운캐스팅 (자손 <-조상) - 캐스팅 필수!! 

## 5.3 instance of 연산자
- 참조변수가 참조하는 인스턴스의 실제 타입을 알아보기 위해 사용되는 연산자 
- instance of의 연산결과가 true라면 참조변수가 검사한 타입으로 형변환이 가능 

# 6. 추상클래스

## 6.1 추상클래스
- 클래스를 설계도에 비유한다면, 추상클래스는 미완성 설계도
- 추상클래스는 마완성 메소드를 포함하고 있다.
- 추상클래스 자체로는 클래스로서의 역할 다 못하지만 새 클래스 작성하는데 있어서, 바탕이 되는 조상클래스로서 중요 의미 
- 클래스 선언부에 abstract 붙여주면 ㅗ딘다.

## 6.2 추상메소드
 - 선언부만 작성, 구현부는 작성 x 남겨둔 것
 - 실제 내용은 추상클래스 상속받는 자손클래스에서 구현해줘야한다.
 
 ## 6.3 추상클래스의 작성 
 > - 추상화 ) 클래스 간 공통점 찾아내, 공통의 조상 만드는 작업
 - 구체화) 상속을 통해 클래스 구현, 확장 작업 
 - 굳이 abstract 붙여서 추상메서드 선언 이유는, 자손 클래스에서 추상메서드를 반드시 구현하도록 강요하기 위해서

## 추상메소드의 사용이유! 
- 만일 추상메서드로 정의 x, 빈 몸통만 가지도록 정의된다면 상속받는 자손 클래스에서는 메서드들이 온전히 구현된 것으로 인식, 오버라이딩 통해 클래스에 안 맞게 구현 가능 

- 그러나 추상메소드 구현 시, 자손 클래스 작성할 때 이들이 추상메서드이므로 내용 구현해줘야 함을 인식하고, 자신 클래스에 알맞게 구현할 것 

# 7. 인터페이스 
`인터페이스 vs 추상메소드`
![](https://velog.velcdn.com/images/myway00/post/b258ab95-bf08-49bf-8e9f-1820b948f48c/image.png)
- 추상메소드 : 내부의 기능 확장 위해 존재, 추상메소드가 하나 이상만 있음 된다 (같은 부모로서의 역할) 

- 인터페이스  : 정의된 함수들의 구현 강제 위해(인터페이스가 구현한 객체와 같은 동작 보장), 모든 메소드가 반드시 추상메소드여야 한다. (다른 부모더라도 같은 기능 수행 보장) 

## 7.1 인터페이스 - 일종의 추상클래스
- 그러나 추상클래스보다 추상화 정도가 높은 아이, 추상클래스와 달리 몸통을 갖춘 일반 
메서드 , 멤버변수 가질 수 없음, 오직 추상메서드와 상수만을 멤버로 가짐

> - 추상클래스는 그래도 일반 메소드, 멤버 변수 허용 (미완성 설계도)
- 인터페이스는 모조리 추상클래스여야 한다. 

![](https://velog.velcdn.com/images/myway00/post/1533812b-b849-491f-91ca-7e536bff7c49/image.png)


## 7.3 인터페이스 상속
- 인터페이스가 인터페이스 상속 시 extends
- 클래스가 인터페이스 상속 시 implements 
- 인터페이스는 클래스와 달리 Object 클래스와 같은 최고 조상이 존재 X

## 7.4 인터페이스 구현
- 인터페이스도 추상클래스처럼 그 자체로 인스턴스 생성 불가 
- 클래스가 인터페이스를 IMPLEMENTS 해서 구현하도록 한다, 

## 7.5 인터페이스 다중 상속
- 인터페이스는 STATIC 상수만 정의 가능, 조상 클래스의 멤버변수와 충돌하는 경우는 없고 충돌된다 하더라도 클래스 이름 붙여 구분이 가능 
- 추상메소드는 구현 내용 없으므로 조상 클래스의 메소드와 선언부가 일치하는 경우에는 조상 클래스 쪽의 메소드 상속받으면 됨 

## 7.7 인터페이스의 장점
- 표준화 가능
   - 개발자들에게 인터페이스 구현해 프로그램 작성하게 함 => 일관되고 정형화된 프로그램의 개발 가능 
   
- 서로 관계 없는 클래스들에게 관계 맺어주기 가능
    - 서로 상속도 아니고, 같은 조상클래스 갖고 있지 않은 서로 아무 관계도 없는 클래스들에게 하나의 인터페이스 공통으로 구현해 프로그램 작성하게 하며 관계 맺어주기 가능
    

