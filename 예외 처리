예외 처리
try {
...
}
catch(예외 1){
...}
catch(예외 2){
...
}
public class practice {
    public void run() {
        System.out.println("xx");
    }

    public static void main(String[] args) {
        practice practice = new practice();
        int c;
        try {
            c = 4 / 0;
        } catch (ArithmeticException e) {
            c = -1;
        } finally {
            System.out.println("yy");//무조건 실행됨
            System.out.println(c);//오류 발생, c의 예외처리가 아직 적용 안됨(c가 선언만 되고 숫자 대입은 안 된 상태)
        }
        
    }
}
public class practice {
    public void run() {
        System.out.println("xx");
    }

    public static void main(String[] args) {
        practice practice = new practice();
        int c;
        try {
            c = 4 / 0;
        } catch (ArithmeticException e) {
            c = -1;
        } finally {
            System.out.println("yy");//yy출력 후
        }
        System.out.println(c);//예외처리 된 c, -1이 출력된다.

    }
}
예외를 만드려면
public class practice{
    public void sout(String sout) {
        if("".equals(sout)) {
            return;
        }
        System.out.println("출력 단어:"+sout);
    }

    public static void main(String[] args) {
        practice practice= new practice();
        practice.sout("");//빈칸이니 출력 안 됨
        practice.sout("xx");//"출력단어:xx"라고 출력
    }
}
이 코드에 예외를 추가하면
class soutexception extends RuntimeException{

}
public class practice{
    public void sout(String sout) {
        if("".equals(sout)) {
            throw new soutexception();
        }
        System.out.println("출력 단어:"+sout);
    }

    public static void main(String[] args) {
        practice practice= new practice();
        practice.sout("");
        practice.sout("xx");
    }
}
Runtime exception: 실행시 발생하는 오류, Exception: 컴파일시 발생하는 오류
Exception은 컴파일 시 발생하는 오류, 즉 예측이 가능하다.
위의 예외에서  soutexception extends RuntimeException을 
soutexception extends Exception으로 바꾼다면 컴파일 오류가 발생한다.
Exception은 예측 가능한 오류이기 때문에, 오류 처리가 강제된다.
class soutexception extends Exception{

}
public class practice{
    public void sout(String sout) {
        try {
            if ("".equals(sout)) {
                throw new soutexception();
            }
            System.out.println("출력 단어:" + sout);
        } catch (soutexception e) {
            System.err.println("soutexception이 발생했습니다.");//에러 문구로, soutexception이 발생했습니다 출력
        }
    }

    public static void main(String[] args) {
        practice practice= new practice();
        practice.sout("");
        practice.sout("xx");
    }
}
예외 던지기 throws
예외 처리를 뒤로 미룰 수 있다.
class soutexception extends Exception{
}
public class practice{
    public void sout(String sout) throws soutexception{
        if ("".equals(sout)) {
            throw new soutexception();
        }
        System.out.println("출력 단어:" + sout);
    }
    public static void main(String[] args) {
        practice practice= new practice();
        try {
            practice.sout("");
            practice.sout("xx");//위의 문장에서 에러가 발생했으니 출력 X
        } catch (soutexception e){
            System.err.println("soutexception이 발생했습니다.");
        }
    }
}
트랜잭션(Transaction): 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위
ex)
상품발송() {
    try {
        포장();
        영수증발행();
        발송();
    }catch(예외) {
        모두취소();  // 하나라도 실패하면 모두 취소한다.
    }
}

포장() throws 예외 {
   ...
}

영수증발행() throws 예외 {
   ...
}

발송() throws 예외 {
   ...
}
그러나 예외처리를 각각 하게 된다면,
상품발송() {
    포장();
    영수증발행();
    발송();
}

포장(){
    try {
       ...
    }catch(예외) {
       포장취소();
    }
}

영수증발행() {
    try {
       ...
    }catch(예외) {
       영수증발행취소();
    }
}

발송() {
    try {
       ...
    }catch(예외) {
       발송취소();
    }
}
코드가 꼬일 위험이 크다.
정확한 예외처리로 트랜잭션 관리가 필요하다.
